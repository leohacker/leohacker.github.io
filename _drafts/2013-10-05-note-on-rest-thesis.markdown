---
layout: post
title: "Note on REST thesis"
date: 2013-10-05 20:57
comments: true
categories: [REST]
published: true
toc: true
---

## Preface
REST是一个很吸引人的词汇，buzzword。虽然Roy Thomas Fielding博士在他的论文的绪论部分提到，人们总是不顾需求的实际而 design-by-buzzword，提出一个由当前流行的技术组合的框架。管理层很喜欢这些词汇，采用那些时髦的理论、方法、框架，构架师挂在嘴上的词汇似乎更有说服力，但通常是脱离实际的。REST现在也成为了这样的一个词汇。但是我怀疑有多少人真正了解当初RTF提出REST这个概念背后所做的实践和研究，了解REST实际是什么意思。RTF的博士论文详细的论述了这一基于网络应用的构架设计风格REST，需要注意的是REST是设计风格，不是具体的构架。HTTP协议是REST风格的一个实现，但基于现实的原因，也不是完全符合REST原则的。

RTF的论文就像其他的博士论文一样，创造了一套自己的理论和词汇，参考丰富的学术研究成果，于是也是难于阅读和理解的。我陆续在一周的时间里面阅读和思考，最终有点豁然开朗的感觉。以前我阅读《HTTP权威指南》，只想读开始的几章，认为后面的章节内容离我很远。在读过RTF的论文后，我才发觉这本书简直就是论文的HTTP解释版本，阅读之如饮甘饴。在RTF的论文中提及的各种组件和基本要素都在此书中一一陈述。

我在这篇博客中将顺着论文的结构记录我的阅读笔记。论文可以分为几大部分：构架风格的研究、网络应用的架构、REST风格和HTTP。

<!-- more -->

## 架构风格的研究
RTF探讨的是网络应用的构架。通信协议对于网络应用是很重要的一个议题，不过论文中提到
> 改变一个应用的交互风格对于性能产生的影响要比改变交互所使用的通信协议更大。

通信协议是基于数学的算法体现，我们已经找到很多优秀的通信协议和编码方式等等。而改进应用的交互风格则对于软件的构架设计是很有可能的。对于Web的构架设计，必须考虑如下环境
> 跨域高延迟的网络和多个可信任的边界，以大粒度(large-grain)的数据对象进行通信。

软件构架是什么？
> 一个软件架构是一个软件系统在其操作的某个阶段的运行时元素的抽象。一个系统可能由很多层抽象和很多个操作阶段组成，每个抽象和操作阶段都有自己的软件架构。

曾经有些人看待软件的架构是以静态的眼光，他们首先看到的是源码。源代码的结构显然不同于软件的结构，虽然代码上也能反映一些模块化的特征。但是
> 软件系统通常拥有多个操作阶段，例如启动、初始化、正常处理、重新初始化和停止。

软件的运行是动态的，所以我们分析软件的构架也要根据运行时来抽象。
> 软件架构的核心是抽象原则：通过封装来隐藏系统的一些细节，从而更好地识别和支持系统的属性。

RTF是在从软件架构研究的角度，目的是提出一种架构风格的理论来分析软件架构的元素，并且基于此理论来分析架构约束。根据架构的约束分类现有架构，提出适用于网络应用的REST架构，以及评估REST架构。所以RTF首先关注的是架构的属性：组件、连接器connector和数据。

有一种经典的说法：软件 = 算法 + 数据 。作为最初的计算目的，数据就是要被处理的对象，用函数从一个值计算成为另外一个结果的值，数据在处理过程中变化了。在现代软件工程中，我们使用组件这个概念表示_处理元素_。随着面向接口编程的概念现在也深入人心，我不需要多解释：
> 组件应该由它为其他组件提供的接口和服务来定义，而不是由它在接口之后的实现来定义。

> 也许理解连接器的最佳方式是将它们与组件加以对比。连接器通过将数据元素从它的一个接口转移tranferring到另一个接口而不改变数据，来支持组件的通信。在其内部，一个连接器可以包含一个由组件组成的子系统，为了转移的目的对数据进行某种转换，执行转移，然后做相反的转换并交付与原始数据相同的结果。

RTF清晰的说明了connector的概念，我们不要将它和adapter，proxy等其他概念混淆。在网络应用中connector是常见的。在单机的软件系统中，我们通常没有转移数据的需求，在模块间传递的数据都是为了处理成为另外一个结果或者形式。而在网络中，我们会有纯粹的数据移动的需求。而且connector这个概念有时会被误用，中文的连接这个概念也是相对模糊的，很容易和适配、代理等概念混淆。

我们分析系统的元素，基本可以分为：交互、控制、数据、连接，这几个基本元素。其中我们可以看到MVC模式的影子。在论文也提到 Buschmann & Meunier提出了一种模式的分类方案。
> 根据抽象的粒度(granularity of abstraction)将模式划分为三类：架构框架(architectural framework)、设计模式(design pattern)、习惯用法(idiom)。

设计模式帮助我们解决对象层面的设计问题，习惯用法则可能更多的是具体的细节上的指导。架构框架则是在考虑比较大的约束上的设计决定。论文还提到模式语言。在研究领域，总是有人会提出一种语言来形式化理论，例如模式语言、架构描述语言。在我看来，这种企图形式化设计行为的语言最终都是会失败的，UML是面向具体的需求分析的，尚且越来越少的人使用，更不用说用来描述务虚的模式和架构的语言了。

## 网络应用的架构风格

基于网络的应用系统的架构和分布式系统很相似。分布式系统在用户看来就像是普通的集中式系统，对用户是透明的。而基于网络的系统，无需隐藏网络的存在。在网络应用架构中我们要考虑网络性能，尤其是移动数据的性能。

- throughput 吞吐量是信息，既包括应用数据也包括通信负载，在组件之间转移的速率。
- overhead 负载，可分为初始设置(initial setup)的负载和每次交互的负载。这种区别有助于识别能够跨域多个交互共享设置负载的连接器。
- bandwidth 带宽，是在一个特定的网络连接之上可用的最大的吞吐量。
- usable bandwidth 可用带宽，应用实际可用的那个部分带宽。

用户可以察觉的性能是延迟 latency 和完成时间 completion

- 延迟是指从出发初次请求到得到第一个响应指示之间持续的时间。
- 完成时间是完成一个应用动作所花费的时间。

延迟会发生在几个点：

- 应用识别触发动作的时间所需的时间。
- 组件之间建立交互所需的时间。
- 在组件之间传输交互数据所需的时间。
- 组件处理每次交互请求的时间。
- 完成数据转移和处理交互结果的时间。

完成时间取决于所有上述的延迟点。对延迟的优化设计常常产生延长完成时间的副作用。不过这取决于应用更关心哪个指标。Web浏览器关注延迟，而网络爬虫关心完成时间。

> 最佳的应用性能是通过不使用网络而获得的。

考虑影响网络性能的因素，我们可以重用交互（缓存)，减少网络交互（长连接)，将数据处理移动到距离数据源更近的地方(移动代码风格)，来减少某些交互的必要性。

### 构架指标的术语s

- Scalability 表示在一个主动的配置中，架构支持大量的组件或者大量的组件之间交互的能力。简化组件的功能，分散交互，有助于可伸缩性。

- Simplicity  对组件的设计应用分离关注点原则， principle of separation of concerns 。好像没有在其他地方看过这个术语。组件内聚的意思吧。

- Extensibility 动态可扩展性意味着功能能够被加到一个已经部署的系统中，而不会影响到系统的其他部分。减少组件的耦合，基于事件的响应模块，Hook类似的机制。

- Customizability 临时性的修改、制定一个架构元素的行为的能力。按需代码，动态代码，类似Lisp的那种修改执行代码的能力。

- Configurability 在部署后，对于组件配置的修改。

- Reusability 可重用性。降低组件之间的耦合。

- Visibility  一个组件对于其他组件之间的交互进行监视和仲裁的能力。

- Portability 可移植性

- Reliability 可靠性。避免单点故障，增加冗余，允许监视，对部分故障可恢复。

### 构架风格

- pipe and filter
管道和过滤器风格。Unix系统的命令行，都能处理stdin和stdout，统一的接口。

- Replication
复制风格。缓存。

- Hierarchical
分层风格。分层系统的主要缺点是它们增加了处理数据的开销和延迟，降低了用户可觉察的性能。

- stateless
在服务器组件上不允许有会话状态 session state 。每个请求必须包换理解请求所需的全部信息，不能利用保存在服务器上的context。会话状态保存在客户端。缺点是需要发送重复数据，增加网络传输的开销。

- 远程会话风格
在服务器上启动会话，调用服务，然后退出。客户端可以很简单，应用状态都保存在服务器上。但也就是降低了服务器的可伸缩性。保存了太多的应用逻辑在服务器上，不利于支持新的客户端。

- 远程数据风格      客户端发送数据查询请求到服务器端。服务器分配一个工作空间并执行这个查询，经过多次查询，将最后的较小的数据集传输给客户端。缺点是，客户端必须了解服务器端的状态。

- 移动代码风格
移动代码位置，消除网络通信的交互。JavaScript在浏览器上的应用就是很典型的。

- 基于事件的集成风格
总线Bus机制，接口的通用性很好，容易扩展。不过事件需要轮询和监听，广播事件会导致事件风暴。完全不适合Web这样无法控制边界的巨型网络。可能在系统软件层面上可以有较好地应用。

- 分布式对象
数据被封装为对象，分布式对象系统的核心问题是对象管理、对象交互管理和资源管理。由于是基于对象，通用性不好，数据不能作为通用交互媒介。Brokered Distributed Objects (COBRA)系统的优点很少，系统过于复杂。

## REST 风格

REST风格就是多个风格的继承：

- 客户-服务器
- 无状态
- 缓存
- 统一接口
- 分层
- 按需代码

统一接口是指使用HTTP协议语言作为统一接口，其实也就是使用数据作为接口。数据在多个层中移动，被缓存和代理，使用无状态的交互方式，还有可选的按需代码支持。

在REST风格中，Resources是一个很核心的概念。

> 一个资源是到一组实体的概念上的映射，而不是在任何特定时刻与该映射相关联的实体本身。

资源可以是一份文件，一张图片，也可以是一个网络服务，其他资源的集合等等。资源对应的值是可以变化的，唯一必须是静态的是映射的语义，因为语义才是区别资源的关键。由于Web是分布式系统，过于巨大，所以如何给定一个资源的标识名称，是留给资源的提供者来决定的，也就是URI。

表述，representation。在REST中，使用一个表述来表示资源的当前的或者预期的状态，在组建之间传递该表述。

> 一个表述是一个字节序列，以及描述这些字节的表述元数据。

表述可以是文档、文件、HTTP消息的body、instance或者变量。资源是语义的，表述则是具体的。

> 连接器代表了一个组件通信的抽象接口，通过提供清晰的关注点分离，并且隐藏资源的底层实现和通信机制，从而改善了架构的简单性。

连接器在客户端是libwww-perl库，在服务器端可以是ApacheAPI，可以是缓存，SSL tunnel等。连接器不处理数据。

组件可以是用User agent(浏览器)，origin server(Apache httpd)，网关 Squid、CGI、反向代理，也可以是代理。组件之间是类似管道和过滤器风格，组件之间的交互式动态连接的。由于无状态的交互本质，每个组件都是独立的，伸缩性很好，组件的拓扑结构可以轻易组合和转变。

值得注意的是，REST是pull风格的，而基于事件的集成风格是push风格。push风格不管有没有客户需求，都会发出一个事件通知，显然是低效率的。

## HTTP

### URI
统一资源标识符既是Web架构的最简单元素，也是最重要的元素。

> 在REST中对于“资源”的定义基于一个简单的前提：标识符的改变应该尽可能很少发生。

> REST达到了这个目标，通过将一个资源定义为创作者想要标识的语义，而不是对应于创建这个引用时的那些语义的值。

表述是资源的影子。资源是抽象的语义，表述是资源的载体。
> 如果当资源被访问时，存在着资源的多个表述，可以使用一个内容选择算法来动态地选择一个最适合客户端能力的表述。

在URI的设计中，不要加入会话相关的信息，例如使用用户的ID来跟踪服务器端会话的状态。这样的设计违反了REST的缓存风格。用户之间无法共享那些语义的引用。一个普遍误解是将URI作为对分布式文件系统的定位。而实际上资源的表述可以同时包括有数据和元数据，可以是动态服务，可以没有任何实体对应存在。

### HTTP协议

#### 协议版本
在HTTP的协议簇有0.9、1.0和1.1多个版本。这些版本是在进化的过程中，逐步产生的。HTTP在REST风格的支持下，各个组件是基于统一接口的，在各个版本之间的主要功能上市兼容的，所以HTTP甚至不要求整个请求/响应链中的组件使用相同的版本。非常有趣而且健壮性的设计，令人印象深刻。

#### 状态码
HTTP的响应状态码也是精心设计的成果。

- 1xx 表示消息中包含一个临时的信息响应。
- 2xx 表示请求成功。
- 3xx 表示请求需要被重定向到另外一个资源。
- 4xx 表示客户端发生了一个不应该重复的错误。
- 500 表示服务器端遇到了一个错误。

> 如果接收者不理解一个消息中的状态码的特定语义，那么它们必须将该状态码按照与同一类别中状态码魏x00时相同的方式来处理。

#### 限制
URI的长度也是常常被人们提及的一个限制。不过我们在RTF的论文中可以找到清晰的论述。

> 在HTTP协议中并没有限制URI的长度、头信息字段的长度、表述的长度、或者任何由一列栏目组成的字段值的长度。

早期的Web客户端有255字符的长度限制，现在的浏览器可能还会存在一定长度的限制，不过已经比较长以满足一般的应用需求。服务器可以返回一些状态码表示某个协议元素过长。不过，客户端没有办法通知服务器端它的资源限制。

这里的原则是，不要在协议上制定限制，而是将限制留给应用来决定。这样，我们可以在未来替换组件来扩展限制的支持，而不是修订协议。

#### Keep-alive
早期的HTTP为每个请求和响应建立一个连接，模式很简单，但是效率很低。所以HTTP协议引入了持久连接，使用长度分隔的消息，以便在单个连接中发送多个HTTP消息。

> HTTP/1.1最终决定将持久连接作为默认的选项，这样通过HTTP-version的值作为持久连接存在的信号就足够了。

#### Cookie
HTTP Cookie是不符合REST风格的一个例子。Cookie的目的是保存应用对某个特定用户的配置或者会话的状态信息。但是Cookie通常是与一个完整的站点相关联，而不是与客户端的特定应用状态相关联。

> 发送到相同服务器的下一个请求包含的是一个并没有代表应用上下文的Cookie，这会使得通信的两端都产生混淆。

> Cookie也违反了REST，因为它们允许数据在没有充分表明其语义的情况下进行传递，这样就成为了一个安全和隐私方面的关注点。结合使用Cookie和Referer头信息字段，有可能当用户在多个站点之间浏览时，对他进行跟踪。其结果是，Web上基于Cookie的应用永远都不值得信任。

#### MIME
> 除非是为了安全封装或者打包归档的目的，在HTTP中，将不同的对象打包在单个消息中是没有意义的，因为为那些尚未缓存的文档发送单独的请求会更加有效率。

#### 响应
> 当需要描述哪一个响应属于哪一个请求的时候，HTTP消息并不是自描述的。请求的顺序决定了响应的顺序，这意味着HTTP依赖于传输机制的连接来决定这个匹配。尽管HTTP/1.1被定义为独立于传输协议，但是仍然假设通信是发生在一个同步的传输机制之上。

## 结束语
RTF的论文博大精深，参考文献也是20世纪90年代的经典论文，值得一看。








